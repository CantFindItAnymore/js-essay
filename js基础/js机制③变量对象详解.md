js中，我们会声明变量和函数。js解析器如何找到这些变量呢？这需要我们进一步了解上下文。



### 上下文的生命周期

`创建阶段`

1. **创建变量对象**。
2. 建立作用域链。
3. 确定this指向。

`代码执行阶段`

1. 变量赋值。

2. 函数引用。

   ```javascript
   这一步可能有点奇怪，因为在创建阶段变量对象就已经存储了函数的地址，这里要干嘛？
   
   其实不是那样的，在创建变量对象时，如果函数声明是：
   
   - 声明式 function c () {}：
     则js会直接将(属性：函数声明c，属性值:函数地址）放入变量对象。
     这一步就不需要执行了。
   
   - 表达式 var c = function () {} 或构造函数式 var c = new Function ():
     则js仅仅是将函数声明c放入变量对象中，上下文执行阶段才对c添加引用。
     就是这一步！ 👱‍
   ```

3. 执行其他代码。

4. 执行完出栈，等待被回收。

------

### 创建变量对象

在上下文的创建阶段中，变量对象的创建步骤为：

1. 新建`arguments`对象。依次检查上下文中的参数，在对象中创建所有对应的参数属性和属性值。
2. 检查上下文中的`函数声明`，每找到一个函数，就在变量对象中以函数名创建一个属性，属性值为该函数的内存地址。
3. 检查上下文中的`变量声明`，每找到一个变量，就在变量对象中以变量名创建一个属性，属性值暂时为`undefined`。

------

*注意*，创建**变量**生成的属性时，如果要声明的属性名已经存在（不管是函数还是变量），为防止已声明的函数被修改为`undefined`，此次声明会直接跳过不执行，原属性值不会修改。

*注意*，变量对象是在函数和变量声明时创建属性，而不是赋值时。

*注意*，在进入执行阶段之前，`变量对象`中的属性不能被访问。但是进入执行阶段后，`变量对象`变为了`活动对象`，里面的属性就能被访问了。

------

我们举3个例子：

```javascript
// demo1
{
  function foo() {
    console.log('function foo')
  }
  var foo = 10
  console.log(foo) // 10
}

 

// demo2
{
  console.log(foo) // ƒ foo()
  function foo() {
    console.log('function foo')
  }
  var foo = 10
}

 

// demo3
{
  console.log(b) // undefined
  var b = function () {
    console.log(3)
  }
  console.log(c) // f c()
  function c() {
    console.log(3)
  }
}
```



在demo1中，js是这样执行的：

1. 创建阶段
   - 创建变量对象
     - 创建arguments对象，上下文中没有参数，下一步。
     - 寻找函数声明，找到了foo函数，变量对象创建foo属性，属性值为函数在堆内存中的地址。
     - 寻找变量声明，找到了foo变量。因为变量对象中已有foo属性，所以跳过此步。
   - 建立作用域链。
   - 确定this指向。
2. 执行阶段
   - 变量赋值
     - 将10赋值给变量对象的foo属性。
   - 函数引用
   - 执行其他代码
     - 打印foo，也就是 10。

------

在demo3中，涉及到另一个知识点：

函数声明有3种方式：

\>声明式 function c () {}

\>表达式 var c = function () {}

\>构造函数式 var c = new Function ()

其中，`当函数声明是/表达式或构造函数式时，js仅仅是将函数声明c放入变量对象中，上下文执行阶段才对c添加引用`。

只有当是声明式时，js会直接将/属性：函数声明c/及其属性值（函数地址）/放入变量对象。

------

总结：

\>变量提升是变量对象的创建造成的。

\>函数声明比变量声明更加优先一点。

 

------

特殊的`变量对象`：全局上下文的变量对象

在浏览器中，全局对象为window，它的变量对象就是window对象。

同样的，window的this也指向window。