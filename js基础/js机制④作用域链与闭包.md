### 作用域与上下文的区别

js执行分为两个阶段：

`代码编译`

- 编译器将代码翻译成可执行代码，这个阶段 -> `作用域`会确定。
- 作用域可以理解为一个属性，分为全局作用域，函数作用域，块级作用域。不管调没调用，它都一直存在。

`代码执行`

- js引擎执行可执行代码，这个阶段 -> `上下文`才有可能被创建。
- 上下文可以理解为js分配给你的一块内存，让你在里面存存取取，施展拳脚。
- 并且对于函数来说，上下文在函数被调用时才会被创建，可以理解为/为了存储变量，所以开辟一块空间。



**重点难点**：一个作用域可能存在多个上下文，这对理解闭包很有帮助。

举个例子：

```javascript
var x = 1
function fn (params) {
  return function () {
    console.log(x)
  }
}

var ra = fn(5)
var rb = fn(10)

ra() // 1
rb() // 1
```

分析一波：

1. 编译器编译一下。

   - 此时可以确定全局作用域，函数fn作用域，匿名函数作用域。

2. 编译好了，执行。

3. 全局上下文A入栈

   - 创建阶段
     - 创建变量对象
       - 全局上下文不存在参数，所以arguments对象为空。
       - 寻找函数声明：找到一个fn，存入变量对象，属性值为函数fn的地址。
       - 寻找变量声明：找到x，ra，rb，存入变量对象，属性值均为undefined。
     - 建立作用域链
       - 就全局上下文的变量对象，没有其它的了。
     - 确定this指向
   - 执行阶段
     - 变量赋值：
       - 给变量x赋值为1。
       - ra赋值为fn(5)，此时暂停执行全局上下文A，函数fn上下文B入栈。
       - rb赋值为fn(10)，此时暂停执行全局上下文A，函数fn上下文C入栈。
     - 函数引用：函数fn为声明式表达，所以此步略过。
     - 执行其它代码：`ra()`，emmm，暂停一下，函数ra上下文D入栈，
     - 继续，`rb()`，emmm，再暂停一下，函数rb上下文E入栈。

4. 函数fn上下文B入栈

   - 创建阶段

     - 创建变量对象
       - 创建arguments对象，里面有params属性，值为5。
       - 寻找函数声明：找到一个匿名，存入变量对象，属性值为函数匿名函数的地址。
       - 寻找变量声明：没有。
     - 建立作用域链
       - [函数fn上下文B的变量对象，全局上下文的变量对象]
     - 确定this指向

   - 执行阶段

     - 变量赋值：

       - 没有。

     - 函数引用：匿名函数为声明式表达，所以此步略过。

     - 执行其它代码：

       ```javascript
       return function () {
         console.log(x)
       }
       ```

       将该匿名函数返回给全局上下文A中的ra。

5. 函数fn上下文C入栈（与B一样，不写了。嘤嘤嘤~），将匿名函数返回给全局上下文A中的rb。

   ```javascript
   注意：4和5中，将匿名函数返回后 ，函数fn上下文B和函数fn上下文C 本来应该出栈的。但是匿名函数使用了函数fn上下文中的变量对象。所以不能出栈 （会清除内存），即js会把函数fn上下文B和函数fn上下文C都保留下来。
   此时就是开始说的那种情况：一个作用域有多个上下文。
   ```

6. 现在继续执行全局上下文中剩余的代码

   - 函数ra上下文D入栈

     ```javascript
     function () {
       console.log(x)
     }
     ```

     - 没有什么声明赋值，直接console.log(x)。
     - 在函数ra上下文D的变量对象中寻找x变量，没找到。
     - 根据作用域链规则，一层层往上地 去上层上下文中找x变量。最后在全局上下文的变量对象中找到了！x为1，所以打印1。
     - 出栈。

   - 函数rb上下文E入栈

     同上。

------



### 作用域链

上下文在创建时会生成`变量对象`，生成`作用域链`，确定`this指向`。

- 作用域链是啥？

  作用域链是作用域的具体实现。

  作用域链包含当前上下文与上层上下文的一系列变量对象。

- 用来干嘛？

  保证当前执行环境能访问到符合权限（当前上下文和上层上下文）的变量和函数。

------

先举个栗子：

```javascript
{
  var a = 20
  function test() {
    var b = a + 10
    function innerTest() {
      var c = 10
      return b + c
    }
    return innerTest()
  }
 
  test()
}
```



上例中，有3个上下文。分别是`全局`，函数`test`，函数`innerTest`,

它们分别有变量对象`VO(global)`, `VO(test)`, `VO(innerTest)`。

所以，函数`innerTest`的上下文在创建时，生成的作用域链为 `[VO(innerTest), VO(test), VO(global)]`。

*注意，当前作用域与上层作用域并不是包含关系。

并且作用域链中，当前环境的变量对象总在第一位，全局的变量对象总在最后一位。

------



### 闭包

1. 闭包是啥？

闭包是一个特殊的对象。由两部分组成：`上下文`，`上下文中的函数`。

当上下文中的函数访问了上下文中的变量对象时，就产生了闭包。

chorme中，把被访问的变量对象/所在的/上下文的函数（不是上下文中访问变量对象的函数）名字代指闭包。

*注意，闭包中的上下文不包括全局上下文。也就是，只有函数和块级作用域才能是闭包。

有点不好理解吧？换个角度，看看闭包的两种情况：

- 函数作为返回值

  ```javascript
  function fn () {
    var max = 10
    return function (x) {
      if (x > max) {
        return x
      }
    }
  }
  
  var f1 = fn()
  f1(11)
  ```

  

- 函数作为参数传递

  ```javascript
  var max = 10
  var fn = function (x) {
    if (x > max) {
      console.log(x)
    }
  }
  
  var rr = function (f) {
    var max = 100
   	f(15)
  }
  
  rr(fn)
  ```

------

2. 闭包有啥用？

通过闭包，我们可以在上下文A中，访问到上下文B中的变量对象。

从这点出发，更加能够理解闭包。这个特点也可以实现很多功能，非常牛逼。

------

3. 闭包机制？

我们知道js有垃圾回收机制：当一个内存中的值失去引用时，其占用的内存会被释放回收。

一个上下文被执行完后出栈，其中的变量对象会失去引用。闭包则阻止了变量对象的回收。

所以闭包后能访问到其它上下文中的变量对象。

再举个例子：

```javascript
var fn = null
function foo () {
  var a = 20
  function innerFoo() {
    console.log('尝试读取a：', a)
  }
  fn = innerFoo
}

foo ()
fn ()
```

上例中，一般来说，函数foo执行完后内存就会被回收。

但是，foo中innerFoo函数访问了foo上下文的变量对象a。

并且通过fn=innerFoo将innerFoo这个函数复制了一份在全局上下文的变量对象中。

所以此时通过作用域链，全局上下文和foo上下文就能访问到innerFoo上下文中的变量对象了。yeah！

此时，我们就称函数foo为闭包（有些书籍称innerFoo为闭包，chorme称foo为闭包）。



------



我们先补充一个知识点：`匿名函数`和`自执行函数`

`匿名函数`就是没有名字的函数（妈的废话:angry:)，那么怎么执行它呢？

- 赋值给变量

  ```javascript
  var a = function () {
    alert('a')
  }
  
  a()
  ```

  

- 自执行函数（3种写法）

  ```javascript
  (function(){alert(1)}())
  ```

  ```javascript
  (function(){alert(1)})() 
  ```

  ```javascript
  !function(){alert(1)}() 
  // 或
  void function(){alert(2)}()
  ```

重点来了，为嘛要用自执行函数呢？

为了创建一个独立的作用域，防止变量污染。

也就是创造一个闭包的环境。

举个栗子：

```javascript
var liList = ul.getElementsByTagName('li')
for(var i=0; i<6; i++){
  liList[i].onclick = function(){
    alert(i) // 为什么 alert 出来的总是6,而不是0、1、2、3、4、5
  }
}
```

原因在于，for循环给每个li标签绑定了点击事件，没毛病。

而用户的点击行为肯定在for循环完成之后，点击时触发alert方法，此时才会去寻找i的值。可此时i是6，emmm~

那么怎么解决呢？

自执行函数就很nice，兄嘚：

```javascript
var liList = ul.getElementsByTagName('li')
for(var i=0; i<6; i++){
  (function(ii){
    liList[ii].onclick = function(){
      alert(ii) // 0、1、2、3、4、5
    }
  }(i))
}
```

这样写的话，每次绑定点击事件的时候，事件里面打印的值相当于已经写死了，即当时的i值，这样总的打印出来就是12345了。

我们往深层次分析一下，其实还是应用了闭包。

- 没错！那个匿名函数就是闭包:rabbit:。变量 `ii` 存储在`匿名函数上下文`中的`变量对象`的`arguments`对象中。
- 然后在闭包中将打印函数返回给 -> 全局上下文中li标签的onclick属性。
- 因为闭包的内存不会被回收，所以成功地打印出了12345。YEAH~

完美~所以一定要利用好自执行函数。包括JQuery的$对象就是自执行函数创建的。

扩展一下，除了自执行函数，还有什么解决方案呢？

- 把var改成let即可↓

  ```json
  var liList = ul.getElementsByTagName('li')
  for(let i=0; i<6; i++){
    function(ii){
      liList[ii].onclick = function(){
        alert(ii) // 0、1、2、3、4、5
      }
    }
  }
  ```

为啥可以打印出12345呢？因为let创建了一个块级作用域，相当于在外面包了一层，为闭包创造了环境。

------



- 如果是setTimeout函数的话↓

  一般情况下也是打印出5个6↓

  ```javascript
  for (var i=1; i<=5; i++) {
    setTimeout(
     	function () {
        console.log(i) // 666666
      },
      i*1000
   	)
  }
  ```

  分析一下：对于setTimeout函数，我个人有两种理解

  - 安排A时间后执行函数B。

    如上例中，相当于是安排一下1s后打印i，2s后打印i，...OK，没问题。

    安排好后（这个执行瞬间完成），来打印吧。此时才会去寻找i变量，可是i变量已经是6了。

  - 从js异步机制的角度去理解，setTimeout函数就是在A时间后将函数B放入任务队列中。

    我们忽略放入`将打印i变量的函数放入任务队列`这个操作所消耗的时间。

    那么就是→

    0s时，js执行栈有一个同步任务X→安排A秒后往任务队列中插入B函数，任务队列为空。

    X被瞬间执行。

    1s时，执行同步任务，没有。那就取出任务队列中的第一个（此时也是唯一一个）任务→该函数。

    该函数执行→打印i。i已经为6了。

    ...

    总之，我们把setTimeout函数理解为一种先安排（分配工作），后执行的模式，就容易理解了。

  ------

  下面是破解之法：

  setTimeout函数第一个参数是`要执行的函数`，第二个参数是延迟执行的`时间`。

  以上没问题，可是很少人知道setTimeout函数其实还有第三个可选参数，就是传给`要执行的函数`的参数。

  我们将i作为第三个参数，原理和自执行函数一样。

  ```javascript
  for (var i=1; i<=5; i++) {
    setTimeout( function timer(ii) {
    	console.log(ii) //12345
    }, i*1000, i)
  }
  ```

  分析：

  setTimeout函数内有变量对象内有i属性，

  setTimeout函数内部还有函数timer，timer访问了i变量。

  所以setTimeout函数形成了一个闭包。

------

另一个问题，自执行函数是什么时候执行的呢？

其实，下面两种写法是一样的：

```javascript
var b=function () {}
b()
```

```javascript
(function(){})()
```



------

4. 应用场景

闭包的应用场景主要有二：模块化和柯里化

模块化：先举个栗子：

```javascript
(function () {
  var a = 10
  var b = 20

  function add(num1, num2) {
    var num1 = !!num1 ? num1 : a
    var num2 = !!num2 ? num2 : b
    return num1 + num2
  }
  window.add = add
})()

add(10, 20)
```



这个例子中，我们用函数自执行的方式，创建了一个模块，add公共方法就是对外暴露的接口。

变量a，b为私有变量。

------

这个例子是先让大家对模块有个大致的概念，以后详叙。

记住`模块`这个概念，后面会单独拿出来说。

还有函数的`柯里化`，也会单独拿出来说的。

goodbye~ 