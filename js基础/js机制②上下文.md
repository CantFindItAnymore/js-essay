### 上下文

`上下文` ，可以理解为当前代码的运行环境， 它会形成一个作用域：

1. 全局
2. 函数
3. 块级（一般不会遇到块级作用域）

因此， 在一个js文件中， 很可能会有多个上下文， js引擎则会以`栈`的形式来处理它们。

这个栈， 叫做`函数调用栈(call stack)`。 其中， 栈底永远是全局上下文， 而栈顶是当前正在执行的上下文。

------

### 执行上下文机制

js运行时，上下文是这样生成的：

1. 从一个js程序启动， 代码正常运行， 此时处于全局作用域中。
2. 一旦执行到 `函数` 的代码（ **注意是执行， 不是定义**）， 就会生成一个上下文放入`函数调用栈`中。 此时暂停全局上下文中的代码， 转而执行新加入的上下文中的代码。
3. 当一个上下文中的代码执行完了， 就将这个上下文从`函数调用栈`中移除。继续执行上一个上下文中未执行完的代码。 注意全局上下文只有在浏览器窗口关闭时才会被移除。
4. 循环2~3 步， 直到代码执行完毕。



注意， 函数上下文中的return会直接终止代码执行， 直接将当前上下文弹出`函数调用栈`。

------

总结一下上下文的特点：

1. 单线程
2. 同步执行， 只有`函数调用栈`顶部的上下文处于执行中， 其他上下文需要等待。
3. 全局上下文只有唯一的一个， 它在浏览器关闭时出栈。
4. 函数的上下文的个数没有限制。
5. 每次某个函数被调用， 就会有个新的执行上下文为其创建， 即使调用自己，也是如此。

------

举个栗子：

```javascript
var color = 'pink'

function changeColor () {
  var anotherColor = 'red'
  function swapColors () {
		var tempColor = anotherColor
  	anotherColor = color
  	color = tempColor
  }
  
  swapColors()
}

changeColor()
```

分析：

1. 全局上下文A入栈。
2. 执行全局上下文A中的代码，直到执行到 `changeColor()`，此时激活了函数`changeColor`，创建一个函数上下文B并入栈。
3. 执行函数上下文B中的代码，直到执行到`swapColors()`，此时激活了函数`swapColors`，创建一个函数上下文C并入栈。
4. 执行函数上下文C中的代码，OK，一次性执行完毕。然后上下文C出栈。
5. 上下文B继续执行未执行完的代码，但是没有。所以上下文B直接出栈。
6. 全局上下文A继续执行未执行的代码， 但是没有。那全局上下文A应该出栈了吗？不！只有在浏览器窗口关闭时才会。所以全局上下文A继续存在。

 