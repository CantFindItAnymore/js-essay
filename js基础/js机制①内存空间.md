### 数据结构

堆 `heap`：是一种树状结构。他的存取数据方式，与json格式数据类似，我们只关心键名。

栈` stack`：先进先出。

js中并未严格区分堆和栈，所以 大致可以理解为js所有数据存储在堆中。

队列 `queue`：先进先出。

------

### 变量对象与基础数据类型

js的上下文被创建时，会建一个特殊对象：`变量对象`。

严格来说，`变量对象`也是存储在堆内存中的数据。但为了便于理解我们将其单独提出来。

------

js中有5种`基础类型`：

`Undefined`

`Null`

`String`

`Number`

`Boolean`

(ES6的Symbol先不考虑)

js的基础数据类型会保存在`变量对象`中，并且我们可以直接操作这些数据。

------

多说一句，`基本类型数据是没有方法和属性的`。但我们印象中String, Boolean, Number是有的。怎么回事呢？

为了方便操作这几个基本类型的数据，js在底层做了一些工作，

栗子↓

```javascript
var string = "aaa"
var string2 = string.substring(0)   //aaa

// 相当于↓

var string = new String("aaa")
var string2 = string.substring(0)
string = null
```

每当读取一个基本类型值时，js都会创建一个对应的对象，带有自己的属性和方法，

处理后，`String`就可以操作了。`Boolean`和`Number`也是这个道理。

`String`  `Boolean`  `Number` 这三种类型也叫做  `基本包装类型` 。

------

### 引用数据类型与堆内存

js中有2种`引用类型`：

`Object`

`Function`

js的`引用数据`保存在堆内存中。

js不允许我们直接访问堆内存，因此也不能直接操作堆内存。

那怎么办呢？

js是这样做的：将堆内存中的值的地址保存在`变量对象`中。

这样我们就可以通过地址，存取到引用数据了！(～￣▽￣)～

举个例子：

```javascript
{

  var a1 = 0 // →变量对象
  var a2 = 'this is string' // →变量对象
  var a3 = null // →变量对象

  var b = {
    m: 20
  }  // 变量b存在于变量对象中，其值为{m:20}的地址，{m: 20} 作为对象存在于堆内存中
  var c = [1, 2, 3]  //  变量c存在于变量对象中，其值为[1,2,3]的地址，[1, 2, 3] 作为对象存在于堆内存中
}
```

------

那么接下来，我们就用内存空间的一些特性来验证一下引用类型的特点吧。

```javascript
{
  // demo01.js

  let a = [1, 2]
  let b = a
  b = [3, 4]
  
  // 这时a的值是多少？
}

{
  // demo02.js

  let m = {
    a: 10,
    b: 20
  }
  let n = m
  n.a = 15
  
  // 这时m.a的值是多少？
}
```

demo1中，a和b指向同一个栈内存的地址，b改变则a也跟着改变了？

其实不是这样的！真相是：`变量对象中的数据发生复制行为时，js会自动为新的变量分配一个新的值`。

即，当let b = a时，虽然a，b都等于[1, 2]的地址，但是他们已经是两个相互独立的值了。

然后b的值（堆内存中[1, 2]的地址）改变为[3, 4]的地址。而a的值依然是[1, 2]的地址。

 

demo2中，m复制n时，虽然他们的值指向同一个内存地址，但是已经是两个独立的值了。

再但是，虽然m，n的值独立，但是它们依然指向同一个堆内存。所以n.a改变了,m.a也会跟着改变。

------

### 内存空间的管理。

js具有自动`垃圾收集机制`，内存的分配和回收都完全实现了自动管理。但我们仍然应该了解其机制。

js的`内存生命周期`：

1. 分配你需要的内存。
2. 使用分配的内存（读，写）。
3. 不需要内存时将其释放回收。

举个例子：

```javascript
{
  let a = 20 // 在内存中给数值变量分配空间
  alert(a + 100) // 使用内存
  a = null // 使用完毕之后，释放内存空间
}
```

------

第3步`释放内存`需要重点理解。

`垃圾收集机制`：js会找出那些不再继续使用的值，释放其占用的内存。该操作每隔一段固定的时间执行一次。

那么js是怎么找出不再继续使用的值的呢？最常用的是 `标记清除` 算法。

上例中的 `a=null` 其实做的仅仅是一次释放引用的操作，并没有释放内存。

该内存会在下一次`垃圾收集机制`执行时被找到并释放。

------

注意，

在函数和块级作用域中，当该上下文执行完毕，局部变量也就没有存在的必要了，因此垃圾回收机制很好判断/局部变量是否应该回收了。

但是全局变量什么时候需要释放很难判断，因此开发中我们要避免使用全局变量。