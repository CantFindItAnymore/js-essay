### 一. 编程范式

- 面向对象编程
- 声明式编程
- **函数式编程**
- ...



### 二. 特征

- 函数是第一等公民。
- 强调将计算过程分解为可复用的函数，一般希望粒度较小。
- 纯函数。



### 三. 为什么要这么做？

函数式编程起源于范畴论。

关于范畴论，简单理解为：

范畴是一个容器，他有很多成员和变形关系。成员（对应值）之间可以通过变形关系（对应函数）互相转变。

函数式编程就是范畴论在计算机领域的一个应用。



### 四. 函数的合成与柯里化

函数式编程有两个最基本的运算：合成和柯里化。 

#### 4.1 合成

如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做"函数的合成"（compose）。 

```javascript
const compose = function (f, g) {
  return function (x) {
    return f(g(x));
  };
}
// 调用方式
compose(f, g)(x)
```

函数的合成必须满足结合律，所以要是纯函数。

```javascript
compose(f, compose(g, h))
// 等同于
compose(compose(f, g), h)
// 等同于
compose(f, g, h)
```

#### 4.2 柯里化

`f(x)`和`g(x)`合成为`f(g(x))`，有一个隐藏的前提，就是`f`和`g`都只能接受一个参数。如果可以接受多个参数，比如`f(x, y)`和`g(a, b, c)`，函数合成就非常麻烦。 



这时就需要函数柯里化了。所谓"柯里化"，就是把一个多参数的函数，转化为单参数函数。 

举个栗子↓

```javascript
// 柯里化之前
function add(x, y) {
  return x + y;
}

add(1, 2) // 3

// 柯里化之后
function addX(y) {
  return function (x) {
    return x + y;
  };
}

addX(2)(1) // 3
```



### 五. 函子

#### 5.1 什么是函子

函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。 

函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。 

通俗理解：首先函子也是一个范畴，包含有值和变形关系。它的变形关系可以作用于**每一个值**，将当前容器变形为另一个容器（**生成了新的值而非相互转换**）。

#### 5.1 函子的代码实现

任何具有`map`方法的数据结构，都可以当作函子的实现。 

```javascript
class Functor {
  constructor(val) { 
    this.val = val; 
  }

  map(f) {
    return new Functor(f(this.val));
  }
}

// map函数用传进来的f函数将数据处理一次，就生成了新的函子
// 调用map：
(new Functor(2)).map(function(x) {
  return x + 'rLog'
})
// val由2变成了2rLog
```

**一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。** 



**学习函数式编程，实际上就是学习函子的各种运算。**由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。 

### 六. of方法

上面我们用了new关键字来生成新的范畴，而它是面向对象编程的标志。

函数式编程中，约定使用of来生成新的范畴。

