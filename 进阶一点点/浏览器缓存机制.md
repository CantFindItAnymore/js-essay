### 一. 什么是浏览器缓存

简单来说，浏览器会把已经请求过的web资源（如html页面，图片，js，数据）拷贝一份副本副本存储起来。

当下一个请求到来时，如果是相同的URL，浏览器会根据缓存机制决定是

- 直接使用存储的副本渲染。
- 或者再次发送请求。

关于缓存机制，下面会讲。



### 二. 为嘛使用缓存

- 减少网络带宽消耗

- 降低服务器压力

- 减少网络延迟



### 三. 缓存机制

对于浏览器来说，

`直接使用副本还是重新请求数据`这个规则 是在**HTTP**协议头和**meta**标签中定义的。

它们分别从**新鲜度**和**校验值**两个维度来决定`直接使用副本还是重新请求数据`。

- 新鲜度（过期机制）

  也就是缓存副本的有效期。一个副本必须至少满足以下两个条件中的一个，浏览器才会认为该副本是有效的：

  - 含有完整的过期时间控制头信息（HTTP协议报头），且在有效期内。
  - 浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过其新鲜度。

- 校验值（验证机制）

  服务器返回资源的时候有时会在控制头信息上带有这个资源的实体报头，它可以用于浏览器再次请求过程的校验标识。

  如果发现校验标识不匹配，说明资源已经过期。浏览器会重新请求数据。

### 四. 缓存的控制

#### 1. 使用meta标签

```javascript
<meta http-equiv="Pragma" content="no-cache">  
<!- Pragma是http1.0版本中给客户端设定缓存方式之一，具体作用会在后面详细介绍 -->
```

　上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。

只支持IE了，不用了~再见:blonde_woman: 

#### 2. 使用缓存相关的报头

**Cache-Control**：用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制） 

**Last-Modified**：实体报头用于指示资源的最后修改日期和时间

**Expires**：实体报头给出响应过期的日期和时间



 **Cache-Control与Expires**

Cache-Control与Expires的作用一致，都是指明当前资源的**有效期**，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的**选择更多，设置更细致**，如果同时设置的话，其**优先级高于Expires**



### 五. 不能被缓存的请求

- post请求
- HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），或Cache-Control:max-age=0等告诉浏览器不用缓存的请求 
- 需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的 
- HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存 

### 六. 请求流程

![](https://images2015.cnblogs.com/blog/1028513/201704/1028513-20170420165136790-834238622.png)