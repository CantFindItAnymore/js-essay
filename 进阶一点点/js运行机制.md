 ### 一. 进程与线程

我们知道，js是单线程的。那么线程是什么呢？

我们先了解一下进程和线程：

- 进程：CPU资源分配的最小单位。
- 线程：CPU调度的最小单位。
- 一个进程由多个线程组成，每个线程是进程的不同执行路线。进程之间相互独立。

比如，当浏览器打开一个新的标签页时，CPU会给浏览器分配一个新的进程，去渲染我们的网页。

而渲染网页这个工作是通过这个进程中的多个线程配合来完成的。包括

- 网页渲染的线程
- js引擎线程
- http请求线程
- 等等~



 ### 二. 浏览器的5大线程

浏览器内核是多线程的，在内核的控制下，多个线程相互配合以保持同步，一个浏览器内核通常由以下几个线程组成：

#### 1、GUI渲染线程

- 该线程主要负责解析HTML、CSS，构建DOM树，布局和绘制。
- 当页面需要重绘或引起回流时，会执行该线程。
- 注意，该线程与js引擎线程互斥。当执行JS引擎线程时，GUI线程会挂起。等到任务队列为空时，主线程才会去执行GUI线程。

#### 2、JS引擎线程

- 主要负责js代码的执行。

- 也负责执行准备好执行的事件。比如任务队列中的任务。

- 因为js引擎线程与GUI线程互斥，所以js引擎执行js代码时间过长的话会造成页面阻塞。

  因此我们将<script>标签放在<body>的最后面。

#### 3、定时器触发线程

- 负责定时器一类函数的进程，如setTimeout，setInterval
- 当主线程执行代码时，遇到定时器计时器，会将其交给这个线程处理。x时间后，这个线程会将定时器计时器中的函数加入到任务队列的尾部，等待js引擎执行。

#### 4、事件触发线程

- 主要负责将准备好执行的事件交给js引擎线程执行。比如定时器计时完毕后的回调事件，AJAX请求成功后的回调函数，用户的点击事件的回调函数。该线程会将这些事件加入到任务队列的尾部，等待js引擎执行。

#### 5、异步HTTP请求线程

- 负责执行异步请求一类的函数，如ajax，fetch，axios
- 当主线程执行代码时，遇到异步请求，会将该函数交给这个线程处理。当监听的状态码变更时，如果有回调函数，会将回调函数加入任务队列的尾部，等待js引擎执行。



 ### 三. 浏览器的内核

五大主流浏览器内核：

- IE：ie内核
- Chorme：以前是Webkit内核，现在是blink内核
- Safari：webkit内核
- FireFox：gecko内核
- Opera：以前是pestro内核，然后是webkit内核，现在是blink内核

内核不同，有些HTML元素的表现就也有所不同。因为他们的GUI网页渲染线程不一样。



 ### 四. 任务队列

单线程就意味着，所有任务的执行都需要排队，前一个任务结束，后一个任务才能执行，如果一个任务耗时很长，后一个任务不得不一直等待着。

JavaScript的作者意识到这个问题，将所有任务划分为两种，一种是**同步任务**，一种是**异步任务**。

- **同步任务**是指在**主线程**上排队执行的任务，前一个任务结束，后一个任务才能执行。
- **异步任务**是指**不进入主线程**执行，而进入“**任务队列**”的任务，只有当“**任务队列**”通知主线程可以执行了，该任务才会进入主线程。
  - 异步任务又分为两种，**宏任务**和**微任务**。



 ### 五. 事件循环

- 一开始执行栈（任务队列）为空,我们可以把**执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则**。**微任务**队列空，**宏任务**队列里有且只有一个script脚本（全部js代码）。
- 全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的宏任务与微任务，它们会分别被推入各自的任务队列里。同步代码执行完了，全局script脚本会被移出宏队列，这个过程本质上是队列的宏任务的执行和出队的过程。
- 上一步我们出队的是一个宏任务，这一步我们处理的是微任务。但需要注意的是：当宏任务出队时，任务是**一个一个**执行的；而微任务出队时，任务是**一队一队**执行的。因此，我们处理微任务队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。

**主线程从“任务队列”读取事件这个过程，是循环不断的，所以整个这种运行机制就叫做Event Loop(事件循环)。每当主线程为空时，就会去读取“事件队列”，这就是JavaScript的运行机制**



### 六. 宏任务和微任务

- 宏任务包括：**全局script任务、setTimeout、setInterval、setImmediate、I/O操作、UI rendering**
- 微任务包括：**new Promise.then()、MutationObserver**(HTML5新特性)等



举个栗子，这个例子能够很好的帮助理解宏任务和微任务↓

```javascript
Promise.resolve().then(() => {
    console.log('Promse1')
    setTimeout(function () {
        console.log('setTimeout1')
    }, 0)
})
setTimeout(function () {
    console.log('setTimeout2')
    Promise.resolve().then(() => {
        console.log('Promise2')
    })
}, 0)
```

打印结果：**Promise1、setTimeout2、Promise2、setTimeout1** 

分析：

- 进入全局执行栈
- Promise.resolve().then是个微任务，先放入微任务的任务队列。
- setTimeout是个宏任务，先放入宏任务的任务队列。
- ok，主线程执行完了。去任务队列取任务。先执行微任务。
- 所以打印**Promise1**。然后又在宏任务的任务队列中加入一个宏任务。
- 主线程又执行完了，去任务队列中取任务。此时没有微任务，则执行宏任务队列中的第一个。
- 所以打印**setTimeout2。**然后又在微任务的任务队列中介入一个微任务。
- 主线程又执行完了。去任务队列中取任务。有微任务所以先执行微任务。所以打印**Promise2**。
- 主线程又执行完了，去任务队列中取任务。此时没有微任务，则执行红任务队列中的第一个（此时也只有一个）。所以打印**setTimeout1** 。
- 结束。